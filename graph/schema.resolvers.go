package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"token_transfer/graph/model"
)

// Resolver for the transfer field
func (r *mutationResolver) Transfer(ctx context.Context, fromAddress string, toAddress string, amount int32) (int32, error) {
	tx, err := r.DB.Begin()
	if err != nil {
		return 0, err
	}
	defer tx.Rollback()

	// Check token_balance of the sender
	// lock the sender row
	senderBalance, err := r.getTokenBalance(tx, fromAddress)
	if err != nil {
		return 0, err
	}
	if senderBalance < amount {
		return 0, fmt.Errorf("insufficient balance")
	}

	// Lock recipient
	_, err = r.getTokenBalance(tx, toAddress)
	if err != nil {
		// Recipient wallet does not exist - add it to DB
		// Wallet is not visible to others before the commit
		if errors.Is(err, sql.ErrNoRows) {
			if err := r.addWallet(tx, toAddress); err != nil {
				return 0, err
			}
		} else {
			return 0, err
		}
	}

	// Update token balances
	if err := r.updateBalances(tx, fromAddress, toAddress, amount); err != nil {
		return 0, err
	}

	// Commit
	if err := tx.Commit(); err != nil {
		return 0, err
	}

	return senderBalance - amount, nil
}

// Add wallet with 0 tokens
func (r *mutationResolver) addWallet(tx *sql.Tx, address string) error {
	_, err := tx.Exec("INSERT INTO wallets (address, token_balance) VALUES ($1, 0)", address)
	return err
}

// Return token_balance
// Lock wallet row for transaction (until commit)
func (r *mutationResolver) getTokenBalance(tx *sql.Tx, address string) (int32, error) {
	var balance int32
	err := tx.QueryRow("SELECT token_balance FROM wallets WHERE address = $1 FOR UPDATE", address).Scan(&balance)
	return balance, err
}

func (r *mutationResolver) updateBalances(tx *sql.Tx, fromAddress, toAddress string, amount int32) error {
	_, err := tx.Exec("UPDATE wallets SET token_balance = token_balance - $1 WHERE address = $2", amount, fromAddress)
	if err != nil {
		return err
	}
	_, err = tx.Exec("UPDATE wallets SET token_balance = token_balance + $1 WHERE address = $2", amount, toAddress)
	return err
}

// Resolver for the wallet field
func (r *queryResolver) Wallet(ctx context.Context, address string) (*model.Wallet, error) {
	row := r.DB.QueryRow("SELECT address, token_balance FROM wallets WHERE address = $1", address)

	var wallet model.Wallet
	err := row.Scan(&wallet.Address, &wallet.Balance)
	if err != nil {
		return nil, err
	}

	return &wallet, nil
}

// Return MutationResolver implementation
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Return QueryResolver implementation
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
