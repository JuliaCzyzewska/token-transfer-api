package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"hash/fnv"
	"token_transfer/graph/model"
)

// Convert address to int64 using hash
func hashAddress(address string) int64 {
	h := fnv.New64()
	h.Write([]byte(address))
	return int64(h.Sum64())
}

// Resolver for the transfer field
func (r *mutationResolver) Transfer(ctx context.Context, fromAddress string, toAddress string, amount int32) (int32, error) {
	tx, err := r.DB.Begin()
	if err != nil {
		return 0, err
	}
	defer tx.Rollback()

	// Add advisory lock for server and recipient
	// If other transactions try to add lock, they will have to wait
	// until the end of transaction
	if err := r.lockWallets(tx, fromAddress, toAddress); err != nil {
		return 0, err
	}

	// Check token_balance of the sender
	senderBalance, err := r.getTokenBalance(tx, fromAddress)
	if err != nil {
		return 0, err
	}
	if senderBalance < amount {
		return 0, fmt.Errorf("insufficient balance")
	}

	// Check if recipient wallet exists
	_, err = r.getTokenBalance(tx, toAddress)
	if err != nil {
		// If wallet does not exist - add it to DB
		if errors.Is(err, sql.ErrNoRows) {
			if err := r.addWallet(tx, toAddress); err != nil {
				return 0, err
			}
		} else {
			return 0, err
		}
	}

	// Update token balances
	if err := r.updateBalances(tx, fromAddress, toAddress, amount); err != nil {
		return 0, err
	}

	// Commit
	if err := tx.Commit(); err != nil {
		return 0, err
	}

	return senderBalance - amount, nil
}

func (r *mutationResolver) lockWallets(tx *sql.Tx, fromAddress, toAddress string) error {
	senderHash := hashAddress(fromAddress)
	recipientHash := hashAddress(toAddress)

	// locks hashes always in the same order, to avoid deadlock
	if senderHash < recipientHash {
		if err := r.lockHashAddress(tx, senderHash); err != nil {
			return err
		}
		return r.lockHashAddress(tx, recipientHash)

	} else {
		if err := r.lockHashAddress(tx, recipientHash); err != nil {
			return err
		}
		return r.lockHashAddress(tx, senderHash)
	}

}

func (r *mutationResolver) lockHashAddress(tx *sql.Tx, hashAddressKey int64) error {
	_, err := tx.Exec("SELECT pg_advisory_xact_lock($1)", hashAddressKey)
	return err
}

// Add wallet with 0 tokens
func (r *mutationResolver) addWallet(tx *sql.Tx, address string) error {
	_, err := tx.Exec("INSERT INTO wallets (address, token_balance) VALUES ($1, 0)", address)
	return err
}

// Return token_balance
func (r *mutationResolver) getTokenBalance(tx *sql.Tx, address string) (int32, error) {
	var balance int32
	err := tx.QueryRow("SELECT token_balance FROM wallets WHERE address = $1", address).Scan(&balance)
	return balance, err
}

func (r *mutationResolver) updateBalances(tx *sql.Tx, fromAddress, toAddress string, amount int32) error {
	_, err := tx.Exec("UPDATE wallets SET token_balance = token_balance - $1 WHERE address = $2", amount, fromAddress)
	if err != nil {
		return err
	}
	_, err = tx.Exec("UPDATE wallets SET token_balance = token_balance + $1 WHERE address = $2", amount, toAddress)
	return err
}

// Resolver for the wallet field
func (r *queryResolver) Wallet(ctx context.Context, address string) (*model.Wallet, error) {
	row := r.DB.QueryRow("SELECT address, token_balance FROM wallets WHERE address = $1", address)

	var wallet model.Wallet
	err := row.Scan(&wallet.Address, &wallet.Balance)
	if err != nil {
		return nil, err
	}

	return &wallet, nil
}

// Return MutationResolver implementation
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Return QueryResolver implementation
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
